{
  "hash": "bb94639fba010824f641ea56528bb8e3",
  "result": {
    "markdown": "---\ntitle: \"Control flow, loops, and functions\"\nauthor: \"Dr. Alexander Fisher\"\ndate: \"January 18, 2023\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n# Control flow\n\n## `if` statements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) {\n  do stuff # when condition is TRUE\n}\n```\n:::\n\n\n### Examples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1,2,3)\nif (2 %in% x) {\n  print(\"2 is in x!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2 is in x!\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nif (-6) {\n  print(\"Other types are coerced to logical if possible.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Other types are coerced to logical if possible.\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nif (5 %in% x) \n  print(\"5 is in x!\")\n```\n:::\n\n\n. . .\n\nif the statement is `FALSE`, {the code} does not execute\n\n## `if` is not vectorized\n\nWhile many operators and functions in `R` are vectorized,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1,2,3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2.718282  7.389056 20.085537\n```\n:::\n\n```{.r .cell-code}\nlog(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0000000 0.6931472 1.0986123\n```\n:::\n\n```{.r .cell-code}\nx + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n:::\n\n\n. . .\n\n`if` statements are **not**\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x == 1) {\n  print(\"x is 1!\")\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in if (x == 1) {: the condition has length > 1 and only the first\nelement will be used\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is 1!\"\n```\n:::\n:::\n\n\n## Collapsing logical vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3)\nx > 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n:::\n\n\n`any()` and `all()` can help us collapse this to a single argument (like \"or\"/\"and\" logic)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(x > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nall(x > 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (any(x > 0)) {\n  print(\"At least one element of x is greater than 0.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"At least one element of x is greater than 0.\"\n```\n:::\n:::\n\n\n## `else if`, `else` and `ifelse`\n\n::: columns\n::: {.column width=\"33%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 3\nif (x < 0) {\n  \"x is negative\"\n} else if (x > 0) {\n  \"x is positive\"\n} else {\n  \"x is zero\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is positive\"\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"33%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 0\nif (x < 0) {\n  \"x is negative\"\n} else if (x > 0) {\n  \"x is positive\"\n} else {\n  \"x is zero\"\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is zero\"\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"33%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx = -1\nifelse(x > 0,\n       \"positive\",\n       \"not positive\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"not positive\"\n```\n:::\n:::\n\n:::\n:::\n\n# Error checking\n\n## `stop` and `stopifnot`\n\nWe often need to validate user input and function arguments. If our validation fails, we want to report the error and stop execution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nok = FALSE\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!ok)\n  stop(\"Things are not ok.\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): Things are not ok.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(ok)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: ok is not TRUE\n```\n:::\n:::\n\n\n::: callout-note\nAn error (like the one generated by stop) will prevent a quarto document from rendering unless `#| error: true` is set for that code chunk\n:::\n\n## Placing checkpoints\n\nAlways place checkpoints upstream (find errors as quickly as possible).\n\n::: columns\n::: {.column width=\"50%\"}\nBad checkpoint placement\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition_one) {\n  ##\n  ## Do stuff\n  ##\n} else if (condition_two) {\n  ##\n  ## Do other stuff\n  ##\n} else if (condition_error) {\n  stop(\"Condition error occured\")\n}\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\nGood checkpoint placement\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Do stuff better\nif (condition_error) {\n  stop(\"Condition error occured\")\n}\nif (condition_one) {\n  ##\n  ## Do stuff\n  ##\n} else if (condition_two) {\n  ##\n  ## Do other stuff\n  ##\n}\n```\n:::\n\n:::\n:::\n\n## Exercise 1\n\nConsider two vectors, x and y, each of length one. Write a set of conditionals that satisfy the following.\n\n-   If x is positive and y is negative or y is positive and x is negative, print \"knits\".\n-   If x divided by y is positive, print \"stink\".\n-   Stop execution if x or y are zero.\n\nTest your code with various x and y values. Where did you place the stop execution code?\n\n# Loops\n\n## Loop types\n\nR supports three types of loops: `for`, `while`, and `repeat`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (item in vector) {\n##\n## Iterate this code\n##\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile (we_have_a_true_condition) {\n##\n## Iterate this code\n##\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrepeat {\n##\n## Iterate this code\n##\n}\n```\n:::\n\n\n## for loops\n\n`for` loops are used to iterate over items in a vector. They have the following basic form:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (item in vector) perform_action\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (nakama in c(\"Luffy\", \"Nami\", \"Zoro\")) {\n  print(nakama)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Luffy\"\n[1] \"Nami\"\n[1] \"Zoro\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:4) {\n  log(i)\n}\n```\n:::\n\n\n. . .\n\nAutomatic printing is turned off in loops.\n\n## while loops\n\n`while` loops interate until a condition is false\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquares = rep(0, 5)\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ni = 1\nwhile (i < 6) {\n  squares[i] = i^2\n  i = i + 1\n}\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  9 16 25\n```\n:::\n:::\n\n\n## repeat loops\n\n`repeat` loops repeatedly iterate code until a `break` is reached.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni = 1\nsquares = rep(0, 5)\nrepeat {\nsquares[i] = i ^ 2\ni = i + 1\nif (i > 5) {break}\n}\nsquares\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  9 16 25\n```\n:::\n:::\n\n\n## loop keywords: `next` and `break`\n\n-   `next` exits the current iteration and advances the looping index\n-   `break` exits the loop\n-   both `break and`next apply only to the innermost of nested loops.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  if (i %% 2 == 0) {next}\n  print(paste(\"Number\", i, \"is odd.\"))\n  if (i %% 7 == 0) {break}\n  }\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Number 1 is odd.\"\n[1] \"Number 3 is odd.\"\n[1] \"Number 5 is odd.\"\n[1] \"Number 7 is odd.\"\n```\n:::\n:::\n\n\n## Auxiliary loop functions\n\nYou may want to loop over indices of an object as opposed to the object's values. To do this, consider using one of `length()`, `seq()`, `seq_along()`, and `seq_len()`.\n\n::: columns\n::: {.column width=\"50%\"}\n::: columns\n`seq_along(x)` is preferred to `1:length(x)` e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = list()\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\n1:length(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0\n```\n:::\n\n```{.r .cell-code}\nseq_along(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n\n:::\n:::\n\n::: {.column width=\"50%\"}\nMany ways to generate sequences...\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nseq_len(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n:::\n:::\n\n## Exercises\n\n### Exercise 2\n\nConsider the vector x below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(3, 4, 12, 19, 23, 49, 100, 63, 70)\n```\n:::\n\n\nWrite R code that prints the perfect squares in x.\n\n### Exercise 3\n\nConsider `z = c(-1, .5, 0, .5, 1)`. Write R code that prints the smallest non-negative integer k satisfying the inequality $$\n|cos(k)âˆ’z|<0.001\n\n$$ for each component of z.\n\n# Functions\n\n## Function composition\n\nA function is comprised of arguments (formals), and code (body).\n\n::: {.cell}\n\n```{.r .cell-code}\nquadraticRoots = function(a, b, c) {\n  x1 = (-b + sqrt((b^2) - (4*a*c))) / (2*a)\n  x2 = (-b - sqrt((b^2) - (4*a*c))) / (2*a)\n  return(c(x1, x2))\n}\n\nquadraticRoots(1, -2, -3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3 -1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nformals(quadraticRoots)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n\n\n$b\n\n\n$c\n```\n:::\n\n```{.r .cell-code}\nbody(quadraticRoots)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    x1 = (-b + sqrt((b^2) - (4 * a * c)))/(2 * a)\n    x2 = (-b - sqrt((b^2) - (4 * a * c)))/(2 * a)\n    return(c(x1, x2))\n}\n```\n:::\n:::\n\n## Returns\n\nThere are two approaches to returning values from functions in R - explicit and implicit returns.\n\nExplicit - using one or more return function calls\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function(x) {\n  return(x * x)\n}\nf(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n. . .\n\nImplicit - return value of the last expression is returned.\n\n::: {.cell}\n\n```{.r .cell-code}\ng = function(x) {\n  x * x\n}\ng(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n## Invisible returns\n\nMany functions in R make use of an invisible return value\n\n-   visible\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function(x) {\n  print(x)\n}\ny = f(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n. . .\n\n-   invisible\n\n::: {.cell}\n\n```{.r .cell-code}\ng = function(x) {\n  invisible(x)\n}\ng(2)\nz = g(2)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n## Arguments\n\nWhen defining a function we explicitly define names for the arguments, which become variables within the scope of the function.\n\nWhen calling a function we can use these names to pass arguments in an alternative order.\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function(x, y, z = 1) { # z defaults to 1\n  paste0(\"x=\", x, \" y=\", y, \" z=\", z)\n}\n```\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n::: {.cell}\n\n```{.r .cell-code}\nf(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x=1 y=2 z=3\"\n```\n:::\n\n```{.r .cell-code}\nf(z = 1, x = 2, y = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x=2 y=3 z=1\"\n```\n:::\n\n```{.r .cell-code}\nf(y = 2, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x=1 y=2 z=3\"\n```\n:::\n:::\n:::\n\n::: {.column width=\"50%\"}\n::: {.cell}\n\n```{.r .cell-code}\nf(1)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in paste0(\"x=\", x, \" y=\", y, \" z=\", z): argument \"y\" is missing, with no default\n```\n:::\n\n```{.r .cell-code}\nf(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x=1 y=2 z=1\"\n```\n:::\n\n```{.r .cell-code}\nf(1, 2, 3, 4)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in f(1, 2, 3, 4): unused argument (4)\n```\n:::\n\n```{.r .cell-code}\nf(1 , 2, m = 3)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in f(1, 2, m = 3): unused argument (m = 3)\n```\n:::\n:::\n:::\n:::\n\n## Scope\n\nR has generous scoping rules, if it can't find a variable in the current scope (e.g. a function's body) it will look for it in the next higher scope, and so on.\n\n::: {.cell}\n\n```{.r .cell-code}\ny = 1\nf = function(x) {\n  x + y\n}\nf(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n. . .\n\n::: {.cell}\n\n```{.r .cell-code}\ny = 1\ng = function(x) {\n  y = 2\n  x + y\n}\ng(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n. . .\n\nAdditionally, variables defined within a scope only persist for the duration of that scope, and do not overwrite variables at a higher scopes\n\n## Lazy evaluation\n\nArguments to R functions are not evaluated until needed.\n\n::: {.cell}\n\n```{.r .cell-code}\nf = function(a, b, x) {\n  print(a)\n  print(b ^ 2)\n  0 * x\n}\nf(5, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n[1] 36\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in f(5, 6): argument \"x\" is missing, with no default\n```\n:::\n:::\n\n## Function forms\n\n| Form        | Description                  | Example(s)                |\n|-------------|------------------------------|---------------------------|\n| Prefix      | name comes before arguments  | `log(x, base = exp(1))`   |\n| Infix       | name between arguments       | `+, %>%, %/%`             |\n| Replacement | replace values by assignment | `names(x) <- c(\"a\", \"b\")` |\n| Special     | all others not defined above | `[[, for, break, (`       |\n\n## Help\n\nTo get help on any function, type ?fcn_name in your console, where fcn_name is the function's name. For infix, replacement, and special functions you will need to surround the function with backticks.\n\n::: {.cell}\n\n```{.r .cell-code}\n?mean\n?`for`\n?`+`\n```\n:::\n\nFor functions not in the base package, you can generally see their implementation by entering the function name without parentheses (or using the body function).\n\n::: {.cell}\n\n```{.r .cell-code}\nlm |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                                                         \n1 function (formula, data, subset, weights, na.action, method = \"qr\",    \n2     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, \n3     contrasts = NULL, offset, ...)                                     \n4 {                                                                      \n5     ret.x <- x                                                         \n6     ret.y <- y                                                         \n```\n:::\n:::\n\n## Function best practices\n\n-   Write a function when you have copied code more than twice.\n\n-   Try to use a verb for your function's name.\n\n-   Keep argument names short but descriptive.\n\n-   Add code comments to explain the \"why\" of your code.\n\n-   Link a family of functions with a common prefix: `pnorm()`, `pbinom()`, `ppois()`.\n\n-   Keep data arguments first, then other required arguments, then followed by default arguments. The ... argument can be placed last.\n\n## A summary of R  \n\n> To understand computations in R, two slogans are helpful:\n>\n> Everything that exists is an object.\n>\n> Everything that happens is a function call.\n>\n> --- John Chambers\n\nJohn McKinley Chambers is the creator of the S programming language, and core member of the R programming language project. The R programming is often called a successor to the S programming language.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}