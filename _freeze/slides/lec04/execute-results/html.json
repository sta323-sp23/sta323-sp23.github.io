{
  "hash": "607506a3bebbb356a0f69bc94e7cb37b",
  "result": {
    "markdown": "---\ntitle: \"Object oriented programming\"\nauthor: \"Dr. Alexander Fisher\"\ndate: \"January 25, 2023\"\nexecute:\n  warning: true\nformat: \n    revealjs:\n      smaller: true\n---\n\n\n# Review of types\n\n## R's type hierarchy\n\n-   from most to least complex: class $\\rightarrow$ mode $\\rightarrow$ type\n\n\n::: {.cell}\n\n:::\n\n\n| value             | `typeof()`       | `mode()`       | `class()`       |\n|:------------------|:-----------------|:---------------|:----------------|\n| `TRUE`            | logical | logical | logical |\n| `1`               | double    | numeric    | numeric    |\n| `1L`              | integer   | numeric   | integer   |\n| `\"A\"`             | character  | character  | character  |\n| `NULL`            | NULL | NULL | NULL |\n| `list(1, \"A\")`    | list    | list    | list    |\n| `factor(\"A\")`     | integer    | numeric    | factor    |\n| `function(x) x^2` | closure    | function    | function    |\n| `\\+`              | builtin          | function       | function        |\n| `\\[`              | special          | function       | function        |\n\n. . .\n\nobjects have `class` even if no formal `class` attribute (seen with `attributes()`)\n\n# S3 Object System\n\n## What is S3?\n\n-   S3 is R's core object oriented implementation\n\n-   S3 is the only OO system used in the base and stats packages, and it's the most commonly used system in CRAN packages.\n\n-   S3 is more flexible (read also: easier to break) than traditional object oriented programming you may have seen before (e.g. Java).\n\n. . .\n\nWorking model: S3 is a system where we attach metadata to an object via the `class` attribute.\n\n. . .\n\nOne of the most compelling reasons to use object oriented programming (OOP) is **polymorphism**. Polymorphism means that a developer can consider a function's interface separately from its implementation. \n\n## S3 class specialization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(\"A\",\"B\",\"A\",\"C\")\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint( x )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\" \"B\" \"A\" \"C\"\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint( factor(x) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] A B A C\nLevels: A B C\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint( unclass( factor(x) ) ) # unclass strips the class attribute\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 1 3\nattr(,\"levels\")\n[1] \"A\" \"B\" \"C\"\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.default( factor(x) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 1 3\n```\n:::\n:::\n\n\n. . .\n\n## Other examples\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmean\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x7fa019945990>\n<environment: namespace:base>\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, ...) \nUseMethod(\"t.test\")\n<bytecode: 0x7fa04969c740>\n<environment: namespace:stats>\n```\n:::\n:::\n\n:::\n:::\n\n. . .\n\nNot all base functions use this approach,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n:::\n:::\n\n\n. . .\n\n::: callout-note\nThe `...` (dot-dot-dot) argument means the function can take any number of additional arguments. This is called a \"variable argument\" and it is commonly used so you pass variables to additional nested functions. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 =  function(y = 0, z = 0) {\n  return(y + z)\n}\n\nf2 <- function(x, ...) {\n  return(x + f1(...))\n}\n\nf2(x = 1, y = 2, z = 3)\n```\n:::\n\n:::\n\n## Generics (what's going on!?)\n\n-   An S3 object behaves differently from its underlying base type whenever it's passed to a **generic** function\n\nThe easiest way to tell if a function is a generic is to use `sloop::ftype()` and look for \"generic\" in the output, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sloop)\nftype(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"      \"generic\"\n```\n:::\n:::\n\n\n. . .\n\nFundamentally, the generic function dispatches to a specialized version of the function depending on the class of its input. `UseMethod()` tells a generic to look for the specialized version.\n\nThe syntax for specialized functions is: `<generic>.<class>`\n\n. . .\n\n### Examples\n\nWe can see all the specialized versions of the generic using the `methods()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(\"plot\") |>\n  head(n = 15)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"plot.acf\"           \"plot.data.frame\"    \"plot.decomposed.ts\"\n [4] \"plot.default\"       \"plot.dendrogram\"    \"plot.density\"      \n [7] \"plot.ecdf\"          \"plot.factor\"        \"plot.formula\"      \n[10] \"plot.function\"      \"plot.hclust\"        \"plot.histogram\"    \n[13] \"plot.HoltWinters\"   \"plot.isoreg\"        \"plot.lm\"           \n```\n:::\n:::\n\n\n## Methods of print\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(\"print\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] print.acf*                                          \n  [2] print.AES*                                          \n  [3] print.anova*                                        \n  [4] print.aov*                                          \n  [5] print.aovlist*                                      \n  [6] print.ar*                                           \n  [7] print.Arima*                                        \n  [8] print.arima0*                                       \n  [9] print.AsIs                                          \n [10] print.aspell*                                       \n [11] print.aspell_inspect_context*                       \n [12] print.bibentry*                                     \n [13] print.Bibtex*                                       \n [14] print.browseVignettes*                              \n [15] print.by                                            \n [16] print.changedFiles*                                 \n [17] print.check_bogus_return*                           \n [18] print.check_code_usage_in_package*                  \n [19] print.check_compiled_code*                          \n [20] print.check_demo_index*                             \n [21] print.check_depdef*                                 \n [22] print.check_details*                                \n [23] print.check_details_changes*                        \n [24] print.check_doi_db*                                 \n [25] print.check_dotInternal*                            \n [26] print.check_make_vars*                              \n [27] print.check_nonAPI_calls*                           \n [28] print.check_package_code_assign_to_globalenv*       \n [29] print.check_package_code_attach*                    \n [30] print.check_package_code_data_into_globalenv*       \n [31] print.check_package_code_startup_functions*         \n [32] print.check_package_code_syntax*                    \n [33] print.check_package_code_unload_functions*          \n [34] print.check_package_compact_datasets*               \n [35] print.check_package_CRAN_incoming*                  \n [36] print.check_package_datalist*                       \n [37] print.check_package_datasets*                       \n [38] print.check_package_depends*                        \n [39] print.check_package_description*                    \n [40] print.check_package_description_encoding*           \n [41] print.check_package_license*                        \n [42] print.check_packages_in_dir*                        \n [43] print.check_packages_used*                          \n [44] print.check_po_files*                               \n [45] print.check_pragmas*                                \n [46] print.check_Rd_line_widths*                         \n [47] print.check_Rd_metadata*                            \n [48] print.check_Rd_xrefs*                               \n [49] print.check_RegSym_calls*                           \n [50] print.check_S3_methods_needing_delayed_registration*\n [51] print.check_so_symbols*                             \n [52] print.check_T_and_F*                                \n [53] print.check_url_db*                                 \n [54] print.check_vignette_index*                         \n [55] print.checkDocFiles*                                \n [56] print.checkDocStyle*                                \n [57] print.checkFF*                                      \n [58] print.checkRd*                                      \n [59] print.checkRdContents*                              \n [60] print.checkReplaceFuns*                             \n [61] print.checkS3methods*                               \n [62] print.checkTnF*                                     \n [63] print.checkVignettes*                               \n [64] print.citation*                                     \n [65] print.cli_ansi_html_style*                          \n [66] print.cli_ansi_string*                              \n [67] print.cli_ansi_style*                               \n [68] print.cli_boxx*                                     \n [69] print.cli_diff_chr*                                 \n [70] print.cli_doc*                                      \n [71] print.cli_progress_demo*                            \n [72] print.cli_rule*                                     \n [73] print.cli_sitrep*                                   \n [74] print.cli_spark*                                    \n [75] print.cli_spinner*                                  \n [76] print.cli_tree*                                     \n [77] print.codoc*                                        \n [78] print.codocClasses*                                 \n [79] print.codocData*                                    \n [80] print.colorConverter*                               \n [81] print.compactPDF*                                   \n [82] print.condition                                     \n [83] print.connection                                    \n [84] print.CRAN_package_reverse_dependencies_and_views*  \n [85] print.data.frame                                    \n [86] print.Date                                          \n [87] print.default                                       \n [88] print.dendrogram*                                   \n [89] print.density*                                      \n [90] print.difftime                                      \n [91] print.dist*                                         \n [92] print.Dlist                                         \n [93] print.DLLInfo                                       \n [94] print.DLLInfoList                                   \n [95] print.DLLRegisteredRoutines                         \n [96] print.document_context*                             \n [97] print.document_position*                            \n [98] print.document_range*                               \n [99] print.document_selection*                           \n[100] print.dummy_coef*                                   \n[101] print.dummy_coef_list*                              \n[102] print.ecdf*                                         \n[103] print.eigen                                         \n[104] print.factanal*                                     \n[105] print.factor                                        \n[106] print.family*                                       \n[107] print.fileSnapshot*                                 \n[108] print.findLineNumResult*                            \n[109] print.formula*                                      \n[110] print.fseq*                                         \n[111] print.ftable*                                       \n[112] print.function                                      \n[113] print.getAnywhere*                                  \n[114] print.glm*                                          \n[115] print.hclust*                                       \n[116] print.help_files_with_topic*                        \n[117] print.hexmode                                       \n[118] print.HoltWinters*                                  \n[119] print.hsearch*                                      \n[120] print.hsearch_db*                                   \n[121] print.htest*                                        \n[122] print.html*                                         \n[123] print.html_dependency*                              \n[124] print.htmltools.selector*                           \n[125] print.htmltools.selector.list*                      \n[126] print.infl*                                         \n[127] print.integrate*                                    \n[128] print.isoreg*                                       \n[129] print.json*                                         \n[130] print.key_missing*                                  \n[131] print.kmeans*                                       \n[132] print.knitr_kable*                                  \n[133] print.Latex*                                        \n[134] print.LaTeX*                                        \n[135] print.libraryIQR                                    \n[136] print.listof                                        \n[137] print.lm*                                           \n[138] print.loadings*                                     \n[139] print.loess*                                        \n[140] print.logLik*                                       \n[141] print.ls_str*                                       \n[142] print.medpolish*                                    \n[143] print.method_table*                                 \n[144] print.MethodsFunction*                              \n[145] print.mtable*                                       \n[146] print.NativeRoutineList                             \n[147] print.news_db*                                      \n[148] print.nls*                                          \n[149] print.noquote                                       \n[150] print.numeric_version                               \n[151] print.object_size*                                  \n[152] print.octmode                                       \n[153] print.packageDescription*                           \n[154] print.packageInfo                                   \n[155] print.packageIQR*                                   \n[156] print.packageStatus*                                \n[157] print.pairwise.htest*                               \n[158] print.person*                                       \n[159] print.POSIXct                                       \n[160] print.POSIXlt                                       \n[161] print.power.htest*                                  \n[162] print.ppr*                                          \n[163] print.prcomp*                                       \n[164] print.princomp*                                     \n[165] print.proc_time                                     \n[166] print.quosure*                                      \n[167] print.quosures*                                     \n[168] print.raster*                                       \n[169] print.Rd*                                           \n[170] print.recordedplot*                                 \n[171] print.restart                                       \n[172] print.RGBcolorConverter*                            \n[173] print.rlang_box_done*                               \n[174] print.rlang_box_splice*                             \n[175] print.rlang_data_pronoun*                           \n[176] print.rlang_dict*                                   \n[177] print.rlang_dyn_array*                              \n[178] print.rlang_envs*                                   \n[179] print.rlang_error*                                  \n[180] print.rlang_fake_data_pronoun*                      \n[181] print.rlang_lambda_function*                        \n[182] print.rlang_message*                                \n[183] print.rlang_trace*                                  \n[184] print.rlang_warning*                                \n[185] print.rlang_zap*                                    \n[186] print.rlang:::list_of_conditions*                   \n[187] print.rle                                           \n[188] print.rlib_bytes*                                   \n[189] print.rlib_error_3_0*                               \n[190] print.rlib_trace_3_0*                               \n[191] print.roman*                                        \n[192] print.scalar*                                       \n[193] print.sessionInfo*                                  \n[194] print.shiny.tag*                                    \n[195] print.shiny.tag.env*                                \n[196] print.shiny.tag.list*                               \n[197] print.shiny.tag.query*                              \n[198] print.simple.list                                   \n[199] print.smooth.spline*                                \n[200] print.socket*                                       \n[201] print.srcfile                                       \n[202] print.srcref                                        \n[203] print.stepfun*                                      \n[204] print.stl*                                          \n[205] print.StructTS*                                     \n[206] print.subdir_tests*                                 \n[207] print.summarize_CRAN_check_status*                  \n[208] print.summary.aov*                                  \n[209] print.summary.aovlist*                              \n[210] print.summary.ecdf*                                 \n[211] print.summary.glm*                                  \n[212] print.summary.lm*                                   \n[213] print.summary.loess*                                \n[214] print.summary.manova*                               \n[215] print.summary.nls*                                  \n[216] print.summary.packageStatus*                        \n[217] print.summary.ppr*                                  \n[218] print.summary.prcomp*                               \n[219] print.summary.princomp*                             \n[220] print.summary.table                                 \n[221] print.summary.warnings                              \n[222] print.summaryDefault                                \n[223] print.table                                         \n[224] print.tables_aov*                                   \n[225] print.terms*                                        \n[226] print.ts*                                           \n[227] print.tskernel*                                     \n[228] print.TukeyHSD*                                     \n[229] print.tukeyline*                                    \n[230] print.tukeysmooth*                                  \n[231] print.undoc*                                        \n[232] print.vignette*                                     \n[233] print.warnings                                      \n[234] print.xfun_raw_string*                              \n[235] print.xfun_rename_seq*                              \n[236] print.xfun_strict_list*                             \n[237] print.xgettext*                                     \n[238] print.xngettext*                                    \n[239] print.xtabs*                                        \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n## Find the documentation\n\nWrite the name of the function to see its definition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, quote = FALSE, max.levels = NULL, width = getOption(\"width\"), \n    ...) \n{\n    ord <- is.ordered(x)\n    if (length(x) == 0L) \n        cat(if (ord) \n            \"ordered\"\n        else \"factor\", \"(0)\\n\", sep = \"\")\n    else {\n        xx <- character(length(x))\n        xx[] <- as.character(x)\n        keepAttrs <- setdiff(names(attributes(x)), c(\"levels\", \n            \"class\"))\n        attributes(xx)[keepAttrs] <- attributes(x)[keepAttrs]\n        print(xx, quote = quote, ...)\n    }\n    maxl <- if (is.null(max.levels)) \n        TRUE\n    else max.levels\n    if (maxl) {\n        n <- length(lev <- encodeString(levels(x), quote = ifelse(quote, \n            \"\\\"\", \"\")))\n        colsep <- if (ord) \n            \" < \"\n        else \" \"\n        T0 <- \"Levels: \"\n        if (is.logical(maxl)) \n            maxl <- {\n                width <- width - (nchar(T0, \"w\") + 3L + 1L + \n                  3L)\n                lenl <- cumsum(nchar(lev, \"w\") + nchar(colsep, \n                  \"w\"))\n                if (n <= 1L || lenl[n] <= width) \n                  n\n                else max(1L, which.max(lenl > width) - 1L)\n            }\n        drop <- n > maxl\n        cat(if (drop) \n            paste(format(n), \"\"), T0, paste(if (drop) \n            c(lev[1L:max(1, maxl - 1)], \"...\", if (maxl > 1) lev[n])\n        else lev, collapse = colsep), \"\\n\", sep = \"\")\n    }\n    if (!isTRUE(val <- .valid.factor(x))) \n        warning(val)\n    invisible(x)\n}\n<bytecode: 0x7fa01974f030>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n## Missing print functions?\n\nThere is no method to print integers specifically:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.integer\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'print.integer' not found\n```\n:::\n:::\n\n\n. . .\n\n-   When a method for a specific class is not found, the default will be called:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.default\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, \n    right = FALSE, max = NULL, width = NULL, useSource = TRUE, \n    ...) \n{\n    args <- pairlist(digits = digits, quote = quote, na.print = na.print, \n        print.gap = print.gap, right = right, max = max, width = width, \n        useSource = useSource, ...)\n    missings <- c(missing(digits), missing(quote), missing(na.print), \n        missing(print.gap), missing(right), missing(max), missing(width), \n        missing(useSource))\n    .Internal(print.default(x, args, missings))\n}\n<bytecode: 0x7fa01a9c3f50>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n## What methods are specialized for a class?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"factor\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] [             [[            [[<-          [<-           all.equal    \n [6] as.character  as.data.frame as.Date       as.list       as.logical   \n[11] as.POSIXlt    as.vector     c             coerce        droplevels   \n[16] format        initialize    is.na<-       length<-      levels<-     \n[21] Math          Ops           plot          print         relevel      \n[26] relist        rep           show          slotsFromS3   summary      \n[31] Summary       xtfrm        \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n## Make your own class and class-specific methods\n\n### Create an object of a new class\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncloud = structure(c(1, 2, 3), # object called cloud with some values\n              class = \"first_class\") # new class type\ncloud\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\nattr(,\"class\")\n[1] \"first_class\"\n```\n:::\n:::\n\n\n. . .\n\n### Create a new method for `first_class` objects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.first_class = function(x) {\n  cat(\"Soldier, first class.\\n\")\n  print.default(unclass(x))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(cloud)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSoldier, first class.\n[1] 1 2 3\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(cloud) = \"double\"\nprint(cloud)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n## Exercise 1\n\nCreate a class called \"accounting\". If a numeric vector has this class, function `print()` should print the vector with a $ in front of each number and display values up to two decimals. Create a method for this class and test it on the accounting object `expenses` below\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpenses = structure(\n  c(500.5, 750, 200.3, 305.11),\n  class = \"accounting\")\n\nprint(expenses)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 500.50 750.00 200.30 305.11\nattr(,\"class\")\n[1] \"accounting\"\n```\n:::\n:::\n\n\n::: callout-hint\n- Use `format(500, digits = 2, nsmall = 2)` as a template to round to specific significant digits.\n- Use `paste` or `paste0` to piece strings together.\n:::\n\n## Defining a new S3 Generic\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshuffle = function(x) {\n  UseMethod(\"shuffle\")\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshuffle.default = function(x) {\n  stop(\"Class \", class(x), \" is not supported by shuffle. \\n\", call. = FALSE)\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshuffle.factor = function(f) {\n  factor( sample(as.character(f)), levels = sample(levels(f)) )\n}\nshuffle.integer = function(x) {\n  sample(x)\n}\n```\n:::\n\n\n. . .\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nshuffle( 1:10 )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  6  8  5  7  3  4 10  2  9\n```\n:::\n\n```{.r .cell-code}\nshuffle( factor(c(\"A\",\"B\",\"C\",\"A\")) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] B C A A\nLevels: B A C\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nshuffle( c(1, 2, 3, 4, 5) )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: Class numeric is not supported by shuffle. \n```\n:::\n\n```{.r .cell-code}\nshuffle( letters[1:5] )\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: Class character is not supported by shuffle. \n```\n:::\n:::\n\n\n:::\n:::\n\n## Exercise 2\n\nBelow is an S3 method called `report`, it is designed to return a message about the type/mode/class of an object passed to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreport = function(x) {\n  UseMethod(\"report\")\n}\nreport.default = function(x) {\n  \"This class does not have a method defined.\"\n}\n```\n:::\n\n\nCreate an implementation for classes `integer`, `double` and `numeric`. The functions should print to the screen \"I'm an integer\", \"I'm a double\", and \"I'm a numeric\" respectively.\n\nNext,\n\n- run `report(1)` and `report(1L)`.\n- run `rm(\"report.integer\")` and re-run the functions. What has changed?\n- look at `class(1)`, `mode(1)`, `typeof(1)`. Does this surprise you?\n\n. . . \n\n- Integers and doubles violate the typical `class` searching rule.\n\n# Some classes\n\n## `Date` class\n\n\nDate vectors are built on top of double vectors. They have class \"Date\" and no other attributes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday = Sys.Date()\n\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nattributes(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$class\n[1] \"Date\"\n```\n:::\n:::\n\n\n. . . \n\n### The dawn of time\n\nThe date is measured in [unix time](https://en.wikipedia.org/wiki/Unix_time), that is, the number of days that have passed since January 1st, 1970. Seconds are counted similarly, startin from the beginning of time, `1970 00:00:00 UTC`.\n\n. . . \n\n### Examples\n\n::: columns\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.double(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19385\n```\n:::\n\n```{.r .cell-code}\nunclass(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19385\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndate = as.Date(\"1970-01-11\")\n\nunclass(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n:::\n:::\n\n## Date-times\n\nR offers two ways to store date-time info. `POSIXct`, and `POSIXlt`\n\n- POSIX stands for \"Portable Operating Systems Interface\" X (\"across\") platforms\n\n  - `ct`: calendar time\n  - `lt`: local time\n\n`ct` is the simplest, is built on top of an atomic vector, and is most appropriate for use in data frames. \n\n## Exercise 3\n\n- what class is `today`?\n- how can you find all the different functions that take the class of `today`?\n- how many days until the end of class? Note: the last day of class is April 26. Use `difftime`\n\n\n## Matrices\n\nR supports the creation of 2d data structures (rows and columns) of atomic vector types. Generally these are formed via a call to matrix().\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:4, nrow=2, ncol=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(LETTERS[1:6], 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] \"A\"  \"C\"  \"E\" \n[2,] \"B\"  \"D\"  \"F\" \n```\n:::\n:::\n\n\n:::\n:::\n\n. . .\n\nMatrices in R use column major ordering (data is sorted in column order not row order).\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n(m = matrix(1:6, nrow=2, ncol=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nc(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n(n = matrix(1:6, nrow=3,\n            ncol=2, byrow=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n```\n:::\n\n```{.r .cell-code}\nc(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5 2 4 6\n```\n:::\n:::\n\n\n:::\n:::\n\n## Matrix structure\n\nMatrices (and arrays) are just atomic vectors with a dim attribute attached (they do not have a class attribute, but they do have a class).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = matrix(1:4, ncol=2, nrow=2)\n```\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\nmode(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\nattributes(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 2 2\n```\n:::\n:::\n\n\n:::\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn = letters[1:6]\ndim(n) = c(2L, 3L)\nn\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] \"a\"  \"c\"  \"e\" \n[2,] \"b\"  \"d\"  \"f\" \n```\n:::\n\n```{.r .cell-code}\nclass(n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\n## Arrays\n\nArrays are just an $n$-dimensional extension of matrices and are defined by adding the appropriate dimension sizes.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\narray(1:8, dim = c(2,2,2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\narray(letters[1:6], dim = c(2,1,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1]\n[1,] \"a\" \n[2,] \"b\" \n\n, , 2\n\n     [,1]\n[1,] \"c\" \n[2,] \"d\" \n\n, , 3\n\n     [,1]\n[1,] \"e\" \n[2,] \"f\" \n```\n:::\n:::\n\n\n:::\n:::\n\n\n\n## Data frames\n\nData frames are built on top of lists with attributes: names, row.names, and class. Here the class is `data.frame`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nattributes(cars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$names\n[1] \"speed\" \"dist\" \n\n$class\n[1] \"data.frame\"\n\n$row.names\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n```\n:::\n\n```{.r .cell-code}\nstr(unclass(cars))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n $ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n - attr(*, \"row.names\")= int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\n```\n:::\n:::\n\n\n. . . \n\nA data frame is how R handles heterogeneous tabular data (i.e. rows and columns) and is one of the most commonly used data structure in R.\n\n## Build your own data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf = list(x = 1:3, y = c(\"a\", \"b\", \"c\"), z = c(TRUE, TRUE, TRUE))\n\nattr(df,\"class\") = \"data.frame\"\nattr(df,\"row.names\") = 1:3\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y    z\n1 1 a TRUE\n2 2 b TRUE\n3 3 c TRUE\n```\n:::\n\n```{.r .cell-code}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t3 obs. of  3 variables:\n $ x: int  1 2 3\n $ y: chr  \"a\" \"b\" \"c\"\n $ z: logi  TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    function fireSlideChanged(previousSlide, currentSlide) {\n\n      // dispatch for htmlwidgets\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for reveal\n    if (window.Reveal) {\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\n        fireSlideChanged(event.previousSlide, event.currentSlide);\n      });\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}